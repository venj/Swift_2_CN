//: [<< 第2章Swift导览](@previous) | [Next >>](@next)

/*:

# 语言指南

*/

/*:

## 基础知识

Swift是开发iOS，OS X和watchOS应用的全新语言。尽管如此，Swift的很多方面对于有过C和Objective-C开发经验的程序员来说都会觉得很熟悉。

Swift包含了所有它自己版本的C和Objective-C的数据类型，包括整形`Int`，浮点型`Double`和`Float`，布尔型`Bool`，以及文本数据类型`String`。Swift还提供了加强版的三种集合类型，`Array`，`Set`和`Dictionary`，这些集合类型将在[集合类型]()中详述。

和C一样，Swift使用变量来存储值，用不同的名字来区分变量。Swift还广泛使用了值不会变化的“变量”，它也被称为“常量”，它们比C语言中的常量强大很多。常量在Swift中被广泛使用，在你处理不需要变化的值的时候，常量使得代码更安全，也能更清楚的表明你的使用意图。

除了常见的类型外，Swift还引入了Objective-C中没有的高级数据类型，例如元组(Tuple)。元组使你能够创建和传递一组值。你可以使用元组作为函数唯一的复合返回值，实现从一个函数中同时返回多个值的功能。

Swift还引入了可选类型（optional types），可以处理值不存在的情况。可选类型值可以代表“这是一个值，它等于x”或者“这是一个空值”。可选类型与Objective-C中的`nil`指针的用法类似，但是可选类型可以代表任何数据类型，而不仅限于类。可选类型比Objective-C中的`nil`更安全，意义更丰富。它是Swift的很多强大特性的核心要素。

可选类型是Swift*类型安全*的一个重要的例子。Swift能帮你弄清楚你的代码能处理的数值的类型。如果你的某段代码希望传入一个`String`，那么类型安全机制能帮助你避免不小心传入一个`Int`类型的值。这种限制使你能在开发过程中尽早地发现和修正错误。

*/

/*:

### 常量和变量

常量和变量都有一个名字（例如`maximumNumberOfLoginAttempts或者`welcomeMessage`）和一个某种类型的值（例如数字`10`或者是字符串`Hello`）。常量的值一旦设置，将无法再改变，而变量的值在设置后可以在将来被改成别的值。
*/

/*:

### 声明常量和变量

常量和变量在使用前需要先声明。你可以使用`let`关键词声明常量，用`var`关键词声明变量。下面的例子展示了常量和变量是如何应用在追踪用户登录尝试次数这个场景下的：

*/

let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0

/*:

这段代码用自然语言表达就是：

“声明一个新的常量，叫做`maximumNumberOfLoginAttempts`，并把它的值设定为10。然后再定义一个叫做`currentLoginAttempt`的新变量，并把它的初始值设置为`0`。“

在这个例子中，最大允许的登录次数被定义为一个常量，因为最大值是永远不会变化的。当前的登录尝试次数被定义为变量，因为这个值需要在每次失败的登录常识后增加。

你可以在一行代码中声明多个变量，用逗号将它们分隔开。

*/

var x = 0.0, y = 0.0, z = 0.0

/*:

> **注意**
>
> 如果您的代码中有一个存储值不回发生变化，那么请用`let`将它定义为常量。使用变量保存可以变化的值。

*/

/*:

### 类型标注

你可以在声明常量或变量的时候，提供一个类型标注（Type Annotation。译者注：这里将Annotation翻译成标注，用于区别英语同为annotation的另一个概念：注解），用来清楚的注明常量或变量可以存储的值的类型。你可以在常量或变量名后加上冒号，再加上一个空格，然后加上类型名，来进行类型标注。

下面这个例子为一个名为`welcomeMessage`的变量加上了类型标注，来表明它能保存`String`类型的值。

*/

var welcomeMessage: String

/*:

定义中的冒号意味着：“...的类型是...”，因此上面那行代码可以这样读：

“声明一个名为`welcomeMessage`的变量，它的类型是`String`。”

“...的类型是`String`”意味着“可以存储任何`String`类型的值。”你可以理解成可以存储“某种值”或者“某类值”。

`welcomeMessage`变量现在能被设置为任何字符串类型的值而不会报错。

*/

welcomeMessage = "Hello"

/*:

你可以在一行代码里，定义多个同一类型的相关变量，变量名之间用逗号进行分隔，只需在最后一个变量名后面使用一个类型标记：

*/

var red, green, blue : Double

/*:

> **注意**
>
> 实际使用中，你其实很少会用到类型标记。如果你在定义变量或常量的时候，设定了初始值，Swift几乎总是可以推导出变量或常量的正确类型，详见[类型安全和类型推断]()章节。在上面的`welcomeMessage`的例子中，我们没有给它设定初始值，因此`welcomeMessage`的类型需要使用类型标记指出，而不是从其初始值推断。

*/


/*:

### 给常量和变量命名

常量和变量的名字可以包含任何字符，甚至包括unicode字符：

*/

let π = 3.15159
let 你好 = "你好世界"
let 🐶🐂 = "dogcow"

/*:

常量和变量的名字不能包含空格字符、数学运算符号、箭头以及私有（或非法的）Unicode字符（code point）、或者绘制横线、方框的字符。也不能以数字开头，尽管数字可以出现在名字中的任何其他位置。

一旦你声明了一个某种类型的变量，你不能再次用同样的名字定义另一个变量，不能把它重新定义为另一种类型的变量，也不能把一个常量重新定义为变量或者把变量重新定义为常量。

*/


/*:

> **注意**
>
> 如果你需要定义一个与Swift关键词同名的变量或常量，你需要在使用时用反引号（`）包围变量名。不过还是请尽量避免使用与关键词同名的变量名，除非你真的别无选择。

*/

/*:

你可以把已有变量的值换成另一个类型兼容的值。在下面这个例子中，`friendlyWelcome`的值从`Hello!`被改成了`Bonjour!`：

*/

var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome现在值为 "Bonjour!"

/*:

与变量不同的是，常量的值一旦设置，将无法改变。试图改变常量的值，将在代码编译时报错：

*/

let languageName = "Swift"
//languageName = "Swift++"
// 取消注释上面这行代码会产生一个编译时错误 - languageName cannot be changed （languageName不能修改）

/*:

### 打印常量和变量

你可以使用`print(_:)`函数打印变量或常量的当前值：

*/

print(friendlyWelcome)
// 打印出 "Bonjour!"

/*:

`print(_:)`是一个全局函数，能够把值打印到适当的输出设备，并在后面换行。比如，在Xcode中，`print(_:)`函数会在Xcode的“Console”面板中打印输出。（有一个相关的函数`print(_:appendNewLine:)`实现同样的打印功能，区别是在打印的值后面加换行符是可选的。）

`print(_:)`函数能打印传入的任意`String`值：

*/

print("This is a string")
// 打印"This is a string"

/*:

`print(_:)`函数可以打印更佳复杂的日志消息。这些消息可以包括变量和常量的当前值。

要在一个长字符串中，使用占位符包含变量或常量的值，Swift使用*字符串替换（string interpolation）*机制。Swift使用常量或变量的当前值替换这些占位符。用括号包围变量名，再在开括号前用反斜杠转义：

*/

print("The current value of friendlyWelcome is \(friendlyWelcome)")
// 打印"The current value of friendlyWelcome is Bonjour!"

/*:

> **注意**
>
> 在字符串替换中可以使用的所有选项，将在[字符串替换]()章节中介绍。

*/

/*:

### 注释

你可以在代码中使用注释添加不执行的文本，用来作为笔记或备忘录。Swift编译器编译代码的时候，会忽略注释。

Swift的注释和C语言的注释非常相似。单行注释使用两个正斜杠（`//`）开头：

*/

// 这是一行注释

//: 多行注释以一个正斜杠加星号（`/*`）开头，以星号加正斜杠（`*/`）结尾。

/*  这也是一个注释，
但是写在了多行中 */

/*:

和C语言中的多行注释不同的是，Swift的多行注释是可以嵌套在多行注释中的。你可以在一个多行注释块中，开始一个内部的多行注释，然后关闭内部注释块，最后关闭外部注释块，实现注释嵌套。

*/

/* 这是第一个多行注释的开始
/* 这是第二个，嵌套的多行注释 */
这是第一个多行注释的结尾 */

/*:

嵌套的多行注释让你能够快速简单地注释掉大段的代码，即便代码已经内部包含了多行注释。

*/

/*:

### 分号

和其他语言一样，Swift并不要求你在代码的每行语句后使用分号（`;`）结尾，尽管如果你愿意，你也可以加。如果你在一行中编写多个语句，你就*必须*使用分号分隔：

*/

let cat = "🐱"; print(cat)
// 打印出：🐱

/*:

### 整型

*整型*是不含小数部分的整数类型，例如`42`和`-23`。整型可以是有符号(signed)（正值，零，或者负值）或者是无符号的（正值和零）。

Swift提供了8位，16位，32位和64位的有符号和无符号整型。这些整型的命名规则与C语言类似，8位无符号整型是`UInt8`，32位有符号整型是`Int32`。与Swift中的其它类型一样，这些整型类型都以大写字母开头。

*/

/*:

#### 整型的最大最小值

你可以通过整型的`min`和`max`属性的到每种整型的最小值和最大值：

*/

let minValue = UInt8.min // minValue等于0，类型为UInt8。
let maxValue = UInt8.max // maxValue等于255，类型为UInt8。

/*:

这些属性的值是有着确定长度的数值类型（例如上例种的`UInt8`），因此可以与同类型的其它值一起用在运算表达式中。

*/

/*:

#### Int

在大多数情况下，你在编码时无需选择某种定长的特殊整数类型。Swift提供了另一种整数类型`Int`，该类型和平台原生的字(Word)长一致：

- 32位平台上，`Int`的长度等同于`Int32`。
- 64位平台上，`Int`的长度等同于`Int64`。

除非你需要处理定长的整数类型，否则，请总是在代码中使用`Int`作为普通的整型类型使用。这样能保证代码的一致性和互操作性。即便是在32位平台上，`Int`能够存储范围在`-2,147,483,648`到`2,147,483,647`之间的整数，在大部分情况下，这个整数范围已经足够大了。

*/

/*:

#### UInt

Swift还提供了无符号整型类型，`UInt`，长度和平台原生的字长一致：

- 32位平台上，`UInt`的长度等同于`UInt32`。
- 64位平台上，`UInt`的长度等同于`UInt64`。

> **注意**
>
> 只有在你真的需要一个和平台原生字长一致的无符号整数类型的时候才使用`UInt`。否则，请总是使用`Int`，即便需要存储的值已知为非负数。总是使用`Int`能保证代码的互操作性，避免了不同数值类型之间的互相转换，也附和整数类型的推断（Type Inference）（译者注：整数字面值在进行类型推断的时候，默认为`Int`型。）详见[类型安全与类型推断]()。

*/

/*:

### 浮点数

*浮点数*是有小数部分的数值，例如，`3.14159`，`0.1`和`-273.15`。

浮点类型可以表示一个比整型宽很多的范围，可以保存比`Int`大得多或小得多的数值。Swift提供了两种浮点类型值：

- `Double`代表64位浮点数。
- `Float`代表32位浮点数。

> **注意**
>
> `Double`的精度至少为小数点后15位数，而`Float`的精度最少只有小数点后面6位。你需要根据代码的实际需求以及所需的数值范围选择合适的浮点数类型。在两种浮点类型都适用的情况下，尽量使用`Double`。
*/

/*:
### 类型安全与类型推断

Swift是一种*类型安全*的语言。类型安全的语言鼓励你明确代码中所使用的值的类型。如果你的代码需要传入一个`String`类型的值，你不能错误地传一个`Int`类型的值进去。

因为Swift是类型安全的，它会在编译代码的时候进行*类型检查*，并将所有类型不匹配的情况标记为错误。这使你能在开发过程中尽早捕捉和修复错误。

类型检查能帮助你在处理不同类型的值的时候避免错误的发生。但是这并不意味着你必须为你声明的所有变量和常量指定类型。如果你没有指定你需要的数据的类型，Swift使用*类型推断*来推导出合适的数据类型。类型推断使得编译器能在编译代码的时候，通过检查你提供的值，推断出特定的表达式的结果类型。

因为类型推断，Swift远比C和Objective-C等语言需要更少的类型声明。虽然常量和变量依然是严格确定类型的，但是大部分指定类型的工作已经由编译器帮你做好了。

类型推断在你声明一个带有初始值的常量或变量的时候特别有用。在你声明一个常量或变量的时候，你可以给它赋一个字面值（*literal value*）。（字面值是直接出现在代码中的值，例如，下例中的`42`和`3.14159`。）

例如，如果你为一个没有指定类型的新常量赋值`42`，Swift会认为你要把常量定为`Int`类型，因为你为它设定了看起来像整数的数值：

*/

let meaningOfLife = 42
// meaningOfLife会被推断为Int。

/*:

类似的，如果你指定了一个类型为浮点型的字面值，Swift会推断你希望创建一个`Double`类型：

*/

let pi = 3.14159
// pi会被推断Double类型。

/*:

在推断浮点类型数值时，Swift总是选择`Double`（而不是`Float`）。

如果在表达式中同时包含整数型和浮点型，那么根据这个上下文环境，类型会被推断为`Double`：

*/

let anotherPi = 3 + 0.14159
// anotherPi也会被推断为Double类型。

/*:

字面值`3`没有显式的类型表示，因此最合适的输出类型`Double`是基于加法部分存在浮点值字面量这一点推断出的。

*/

/*:

### 数值字面量

整数字面量可以被写成：

- 一个无前缀的*十进制（decimal）*数值
- 一个以`0b`作为前缀的*二进制（binary）*数值
- 一个以`0o`作为前缀的*八进制（octal）*数值
- 一个以`0x`作为前缀的*十六进制（hexadecimal）*数值

下面所有整数字面量的十进制值均为`17`：

*/

let decimalInteger = 17
let binaryInteger = 0b10001    // 二进制的17
let octalInteger = 0o21        // 八进制的17
let hexadecimalInteger = 0x11  // 十六进制的17

/*:

浮点字面量可以是（无前缀的）十进制数，或者是（以0x作为前缀的）十六进制数。如果数值包含小数点，那么在小数点的两侧必须都包含数字（或者十六进制数）。十进制浮点数还能包含一个可选的*指数*，以小写或大写的`e`来表示；十六进浮点必须包含一个指数，以小写或大写的`p`来表示。

指数为`exp`的十进制数，是基数乘以10<sup>exp</sup>：

- `1.25e2`指`1.25 x 10`<sup>2</sup>，也就是`125`。
- `1.25e-2`指`1.25 x 10`<sup>-2</sup>，也就是`0.0125`。

指数为`exp`的十六进制数，是基数乘以2<sup>exp</sup>：

- `0xFp2`指`15 x 2`<sup>2</sup>，也就是`60.0`。
- `0xFp-2`指`15 x 2`<sup>-2</sup>，也就是`3.75`。

以下所有浮点字面量的十进制值均为`12.1875`。

*/

let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0

/*:

数字字面量还可以包含额外的格式化字符，以方便阅读。无论是整数值和浮点值都可以包含额外的前后缀`0`，也可以包含下划线以增强可读性。这两种格式化字符均不会影响字面量的实际值：

*/

let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1

/*:

### 数值类型转换

在代码中，你应该使用`Int`作为通用的整数常量和变量的类型，即便你知道你将存入的数值是非负数。在日常编码中使用默认的整数类型，能让代码中的常量和变量具备互操作性，并且符合整数字面量的类型推断。

只有在手头的任务有特殊需求的情况下，才去选择其它的整数类型，比如第三方代码中使用了定长数据，或者为了提高性能、改善内存占用、以及其它优化考量等。在这些情况下使用定长类型能帮你捕捉到意外的数值溢出，并同时也隐式地注明了所使用的数据的性质。

*/

/*:

#### 整型转换

每种数字类型的变量或常量能存储的数字的范围各不相同。一个类型为`Int8`的常量或变量能存储`-128`到`127`之间的数，而类型为`UInt8`的常量或变量可以存储`0`到`255`之间的数。如果要赋值的数字超过了定长整型的常量或变量能包含的范围，那么在代码编译的时候会报错（译者注：取消注释下面的代码，查看错误信息）：

*/

// let cannotBeNegtive : UInt8 = -1
// UInt8 不能保存负数，因此上面的代码会报错
// let tooBig : Int8 = Int8.max + 1
// Int8不能存储大于其最大值的数，
// 因此这样代码也会报错。

/*:

因为每种不同的数字类型能存储的数值的范围各不相同，你必须为各种情况进行类型转换。使用类型转换能避免隐藏的转换错误，并让类型转换的意图在代码中明确的表示出来。

要把一种类型的数转换成另一种类型，你需要使用当前值初始化一个目标类型的数。在下面的类型中，常量`twoThousand`的类型为`UInt16`，而常量`one`的类型为`UInt8`。它们之间不能直接相加，因为它们不是同一种类型的。在这个例子中，调用`UInt16(one)`，来使用`one`创建一个新的`UInt16`类型的新值，并使用这个值代替原来的值进行加法运算：

*/

let twoThousand : UInt16 = 2_000
let one : UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)

/*:

因为现在加号两侧的值的类型均为`UInt16`，因此可以进行加法运算了。输出的常量（`twoThousandAndOne`）被推断为`UInt16`，因为结果是两个`UInt16`类型的和。

`SomeType(ofInitialValue)`是用一个初始值，初始化一个Swift类型的值的默认方式。背后的原理是`UInt16`有一个接受`UInt8`类型的构造器，这个构造器被用来将一个已有的`UInt8`类型的值创建一个新的`UInt16`值。不过，你不能传入*任意*类型的值－－传入的值的类型必须是`UInt16`的构造器支持的类型。你可以扩展已有的类型提供可以接受新的数据类型（包括你的自定义类型）的构造器，详见[扩展]()部分。

*/

/*:

#### 整型和浮点型之间的转换

整型和浮点型之间必须显式转换：

*/

let three = 3
let pointOneFourOneFiewNine = 0.14159
let pi_ = Double(3) + pointOneFourOneFiewNine
// pi_等于3.14159，并且被推断为Double类型

/*:



*/





//: [<< 第2章Swift导览](@previous) | [Next >>](@next)
